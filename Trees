/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

public class Solution {

/**************************** MAXIMUM DEPTH OF BINARY TREE  ***********************/

/* Recursive approach using Depth-first traveral:
    Time complexity: O(N) where N is the number of nodes. Follows **Depth-first traversal** manner. 
    Space Complexity: O(h) where h is the height of the binary tree. 
        The maximum depth of the call stack is equal to the height of the binary tree. 
        In the worst case, where the binary tree is skewed (all nodes are in a straight line), the height is equal to the number of nodes, 
        and the space complexity becomes O(n).
        In a balanced binary tree, where the height h is log(n), the space complexity is O(log(n)).
        It's important to note that the space complexity is dominated by the recursive call stack in this implementation. 
        If an iterative approach using a data structure like a queue is used, the space complexity can be reduced to O(n) in the worst case.
*/

    public int recursive_maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }

        int leftDepth = recursive_maxDepth(root.left);
        int rightDepth = recursive_maxDepth(root.right);

        // Return the maximum depth of the left and right subtrees, plus 1 for the current node.
        return Math.max(leftDepth, rightDepth) + 1;
    }


/*  Iterative approach using level order traversal 
    Time Complexity:
        The time complexity is O(n), where n is the number of nodes in the binary tree.
        In the worst case, the algorithm traverses all nodes in the tree once during the level-order traversal.
        Each node is processed once in the inner loop, and there are a total of n nodes in the tree.
    
    Space Complexity:
        The space complexity is O(w), where w is the maximum width of the binary tree (the maximum number of nodes at any level).
        In the worst case, the queue will contain all the nodes at the widest level of the binary tree.
        The space required is proportional to the maximum width of the tree at any level.
        In a balanced binary tree, the maximum width is typically at the bottom level, and the space complexity becomes O(2^(h-1)), where h is the height of the tree.
        In the worst case, where the tree is skewed (all nodes in a straight line), the maximum width is at the top level, 
        and the space complexity is O(1).
*/


        public int iterative_maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int height = 0;

        while (!queue.isEmpty()) {
            int levelSize = queue.size();

            for (int i = 0; i < levelSize; i++) {
                TreeNode current = queue.poll();

                if (current.left != null) {
                    queue.offer(current.left);
                }

                if (current.right != null) {
                    queue.offer(current.right);
                }
            }

            // Increment the height after processing all nodes at the current level
            height++;
        }

        return height;
    }

/*       ****** BINARY TREE LEVEL ORDER TRAVERSAL*********

Input: root = [3,9,20,null,null,15,7]
Output: [[3],[9,20],[15,7]]

Input: root = [1]
Output: [[1]]

Input: root = []
Output: []


TIME COMPLEXITY:  O(N), where N is the number of nodes in the binary tree.
SPACE COMPLEXITY: O(w), where w is the maximum width (number of nodes at any level) of the binary tree.

*/
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();

        if (root == null) {
            return result;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            List<Integer> currentLevel = new ArrayList<>();

            for (int i = 0; i < levelSize; i++) {
                TreeNode current = queue.poll();
                currentLevel.add(current.val);

                if (current.left != null) {
                    queue.offer(current.left);
                }

                if (current.right != null) {
                    queue.offer(current.right);
                }
            }

            result.add(currentLevel);
        }

        return result;
    }

/**************** IS SAME TREE ****************************/
Given the roots of two binary trees p and q, write a function to check if they are the same or not.
Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.

Example 1:
Input: p = [1,2,3], q = [1,2,3]
Output: true

Example 2:
Input: p = [1,2], q = [1,null,2]
Output: false

Example 3:
Input: p = [1,2,1], q = [1,1,2]
Output: false

Time Complexity: O(N),where N is the total number of nodes in the binary tree.
Space Complexity: The space complexity is O(H), where H is the height of the binary tree.
    The function uses the call stack for recursion, and the maximum depth of the call stack is equal to the height of the binary tree.
    In the worst case, the space complexity is O(N) for a skewed tree, where N is the number of nodes.

/**

    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p== null && q!=  null) return false;
        if(q==null && p!=null) return false;
        if(p==null && q==null) return true;
        
        if(p.val == q.val){
            if (isSameTree(p.left, q.left) && isSameTree(p.right, q.right) == true)
                return true;
            else{
                return false;
            }
        }
        else{
            return false;
        }
        
    }

/********************IS BINARY TREE BALANCED ********************************/

/* BOTTOM UP APPROACH - OPTIMISED 
The time complexity of this improved solution is O(N), 
and the space complexity is O(H), where H is the height of the tree.
*/
   public boolean isBalanced(TreeNode root) {
        return checkheight(root)!=-1;
    }
    public int checkheight(TreeNode root) {
        if(root==null)
            return 0;
        int lh = checkheight(root.left);
        if(lh==-1)
            return -1;
        int rh = checkheight(root.right);
        if(rh == -1)
            return -1;
        
        int diff = Math.abs(lh-rh);
        if(diff > 1)
            return -1;
        
        return Math.max(lh,rh)+1;



/************************************ IS SYMMETRIC TREE ************************************************//

public boolean isSymmetric(TreeNode root) {
        if(root == null){
            return false;
        }
        return isSymmetricUtil(root.left, root.right);
    }

public boolean isSymmetricUtil(TreeNode r1, TreeNode r2){
    if(r1== null && r2 == null)
        return true;
    if(r1 == null || r2 == null) 
        return false;
    if(r1.val == r2.val)
        return isSymmetricUtil(r1.left, r2.right) && isSymmetricUtil(r1.right, r2.left);
    return false;
    
}

/*************************************-----MAIN-----------********************************************/


    public static void main(String[] args) {
        // Example usage
        Solution s  = new Solution();

        // Construct a sample binary tree
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);

        // Get the maximum depth (also called height)
        int depth = s.recursive_maxDepth(root);
        System.out.println("Maximum Depth of the Binary Tree: " + depth);

        //Max depth iterative
        int height = s.iterative_maxDepth(root);
        System.out.println("Height of the Binary Tree: " + height);

        //LEVEL ORDER TRAVERSAL
        List<List<Integer>> result = solution.levelOrder(root);
        System.out.println(result);

         // Check if the trees are the same
        boolean result = solution.isSameTree(p, q);
        System.out.println("Are the trees the same? " + result);



    }
}
